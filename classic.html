<style>

/*--- Common ----------------------------------------------------------------*/

/* container */
div.zoomable {
	-background: red; /*!!DEBUG!!*/
	
	--thumb-w: 100px;
	/*--zoom-w: 25%;*/
	--zoom-w: 500px;
	--border-c: grey;
	
	position: relative;
	display: inline-block; /*! Enabling this kills (viewport-)width-percent sizing. */
	vertical-align: top;

	border: 1px solid gray; border: 1px solid var(--border-c);
	margin: 2px 0.5ex;	
}
.zoomable figure.zoom, .zoomable img { margin: 0; padding: 0; }
.zoomable figure.zoom {
	-display: inline-block; /*!!?? This adds the same 2-3 px mysterious bottom offset to the (unpadded) content in
	                               basic mode, which is also there already in the two other modes... :-o */
	background-position: 50% 50%;
	width: 100px; width: var(--thumb-w);
	overflow: hidden;
	cursor: zoom-in;
	
	/* Repeated, since popup mode will use a separate rect.! */
	-border: 1px solid gray; border: 1px solid var(--border-c);
	-border-radius: 2px;
}

.zoomable img {
	display: block; /* Get rid of the descender gap below the images... */
}
.zoomable figure.zoom img {
	width: 100%; /* Without this, the image will grow to a full-height, but horiz. cropped narrow rectangle! */
}
/* Hide the full-size image, while zooming/panning, allowing to show the backgnd. img. */
/* This img. also a) guides the aspect-ratio when sizing the FIGURE,
   and b) resets to thumbnail view, when not zooming. */
.zoomable figure.zoom:hover img { visibility: hidden; }

.zoomable .mag {
	position: absolute;
	bottom: 0; right: 0;
	background: lightblue; opacity: 0.3; border: 1px dotted black;
	padding: 1px 2px;
}
.zoomable:hover .mag { visibility: hidden; }
.zoomable .mag::before { inline; content: "🔍"; }

/* thumbnail */
.zoomable .thumb {
	width: 100px; width: var(--thumb-w);
	cursor: zoom-in;
}

/*--- Basic in-place zoom ---------------------------------------------------*/

/* In this mode, there's no separate thumbnail, so the full-size image is shown
   when no zooming, to reset the panning position & zoom level. */

.zoomable.basic img.thumb { display: none; }

.zoomable.basic figure.zoom:hover {
	width: 500px; width: var(--zoom-w);
	transition: width 0.1s;
	-border: 2px solid red;
}


/*--- In-place zoom ---------------------------------------------------------*/

/* In this mode, there's a separate thumbnail to support proper sizing, because
   the zoomed view is not part of the content flow (-> `pos.: abs.`). */

.zoomable.inplace figure.zoom {
	position: absolute; /* cover the thumbnail, wo. affecting the layout */
	top: 0; left: 0;
	width: 100px; width: var(--thumb-w);
	-border-radius: 3px;
}
.zoomable.inplace figure.zoom:hover {
	width: 500px; width: var(--zoom-w);
	z-index: 10; /* some subsequent elements did cover this otherwise */
	-border: 2px solid darkred;
}


/*--- Popup zoom ------------------------------------------------------------*/

/* The magnified view is as separate image, only shown, when hovering the thumb. */

/* In this mode, the full-size image must be explicitly hidden, as the default
   "hide on hover" does not apply here (because it's a different element). */

.zoomable.popup figure.zoom img { visibility: hidden; }

.zoomable.popup figure.zoom { display: none; }
.zoomable.popup > img:hover ~ figure {
	display: inline; /* turn displaying back on; `inline` for preserving the vert. pos. */
	position: absolute; /* remove from flow, leave original pos. */
	top: 0;	left: 100px; left: --thumb-w;
	margin-left: 1ex; margin-top: -1ex;
	width: 500px; width: var(--zoom-w);
	z-index: 10; /* some subsequent elements did cover this otherwise */
	-border: 2px solid gray;
	-border-radius: 3px;
}

</style>

<script>
function zoompanner(e, zoompad, zoomview) {
	var img = zoomview.getElementsByTagName('img')[0];
	if (img.naturalHeight < img.height || img.naturalWidth < img.width) {
	    zoomview.style.backgroundSize = 'cover';
	    return;
	}
	e.offsetX !== null ? offsetX = e.offsetX : offsetX = e.touches[0].pageX;
	e.offsetY !== null ? offsetY = e.offsetY : offsetY = e.touches[0].pageY;
	//console.log("X=" + offsetX + ", Y=" + offsetY);
	x = offsetX / zoompad.offsetWidth * 100
	y = offsetY / zoompad.offsetHeight * 100
	// Yes, it did go to negative at the edges (depending on the cursor?), causing wraparound of the bg img...:
	if (x < 0) x = 0;
	if (y < 0) y = 0;
	//console.log(zoomview.style.backgroundPosition + " --> " + "zbX=" + x + ", zbY=" + y);
	zoomview.style.backgroundPosition = x + '% ' + y + '%';
}

function zoom(e) {
	zoompanner(e, e.currentTarget, e.currentTarget);
}

function popup_zoom(e) {
	zoompanner(e, e.currentTarget, e.currentTarget.nextElementSibling);
}

//----------------------------------------
customElements.define('z-img', class extends HTMLElement {
	constructor() {
		super();

		// "Host" attributes are not available in the ctor!
		//console.log("zimg ctor, this.classList=" + this.classList);

		this.tpl = document.getElementById('zoomable-img').content;  
		this.shdom = this.attachShadow({mode: 'open'});
		this.shdom.appendChild(this.tpl.cloneNode(true));

		console.log("zimg ctor: " + this.shdom)
	}
	
	connectedCallback() {
		console.log("zimg connect: this.classList=" + this.classList
			+ ", src=" + this.getAttribute('src'));

		var src = this.getAttribute('src');
		var thumb = this.shdom.getElementById('thumb');
		var large = this.shdom.getElementById('large');
		var zoomv = this.shdom.getElementById('zoomview');
		
		// Set the 'src' img URL where needed:
		thumb.setAttribute('src', src);
		large.setAttribute('src', src);
		zoomv.style = 'background-image: url(' + src + ')';
		
		// Setup the event handlers:
		var mode = this.getAttribute('zoom');
		var omm_teh = (mode == 'popup' ? this.popup_zoom : '');
		var omm_feh = (mode == 'popup' ? '' : this.zoom);
		if (omm_teh) { console.log("set thumb handler -> " + omm_teh); thumb.addEventListener('mousemove', omm_teh); }
		if (omm_feh) { console.log("set fig handler -> " + omm_feh); zoomv.addEventListener('mousemove', omm_feh); }
	}

	zoom(e)       { zoompanner(e, e.currentTarget, e.currentTarget); }
	popup_zoom(e) { zoompanner(e, e.currentTarget, e.currentTarget.nextElementSibling); }

});

</script>
